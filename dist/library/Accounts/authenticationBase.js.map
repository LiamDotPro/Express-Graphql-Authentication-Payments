{"version":3,"sources":["../../../library/Accounts/authenticationBase.js"],"names":["require","config","authenticationBase","process","env","ENVIROMENT","new","target","TypeError","password","hash","then","email","using","connection","query","toLowerCase","_res","length","msg","payload","comparePasswords","u_password","res","user","id","plainText","compare","text","re","test","checkIfEmailInString","catch","e","console","log","name","fullname","u_email","hasOwnProperty","getUserPasswordHashWithEmail","bool","userID","encryptPassword","status","message"],"mappings":"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","file":"authenticationBase.js","sourcesContent":["require('dotenv').config();\r\n\r\nimport getSqlConnection from '../../db/db';\r\nimport Promise from 'bluebird';\r\nimport bcrypt from 'bcrypt';\r\n\r\n/**\r\n * Abstract class that acts as the concrete functions for our registering api.\r\n */\r\nexport default class authenticationBase {\r\n\r\n    constructor() {\r\n        if (process.env.ENVIROMENT === 'production' && new.target === authenticationBase) {\r\n            throw new TypeError(\"Cannot construct Abstract instances directly\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encrypts plain text passwords using a safe encryption method.\r\n     * @param password String\r\n     */\r\n    encryptPassword(password) {\r\n        return bcrypt.hash(password, 10).then((hash) => {\r\n            return hash;\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Validates a user from within the database.\r\n     * @param email\r\n     * @param password\r\n     */\r\n    validateUser(email, password) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('Select id, u_email, u_password FROM `accounts` Where u_email=?', [email.toLowerCase()]).then((_res) => {\r\n                // Check if we have that account.\r\n                if (!_res.length > 0) {\r\n                    return {\r\n                        msg: 'Account or password did not match!',\r\n                        payload: 1\r\n                    }\r\n                }\r\n\r\n                return this.comparePasswords(_res[0].u_password, password).then((res) => {\r\n                    // Incorrect password found.\r\n                    if (!res) {\r\n                        return {\r\n                            msg: 'Account or password did not match!',\r\n                            payload: 1\r\n                        }\r\n                    }\r\n\r\n                    // All checks have passed.\r\n                    return {\r\n                        msg: 'Success',\r\n                        payload: 11,\r\n                        user: {\r\n                            id: _res[0].id\r\n                        }\r\n                    }\r\n                })\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This does a simple bcrypt comparision to identify correctness.\r\n     * @param hash\r\n     * @param plainText\r\n     */\r\n    comparePasswords(hash, plainText) {\r\n        return bcrypt.compare(plainText, hash).then((res) => {\r\n            return res === true;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks to make sure an email is present within a string.\r\n     * @param text\r\n     * @returns {boolean}\r\n     */\r\n    checkIfEmailInString(text) {\r\n        let re = /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/;\r\n        return re.test(text);\r\n    }\r\n\r\n    /**\r\n     * This checks for a duplicate account inside the database.\r\n     * Payload is a boolean Int\r\n     */\r\n    checkForDuplicateAccount(email) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n\r\n            if (email.length < 5 || !this.checkIfEmailInString(email)) {\r\n                return {\r\n                    msg: 'Fail - No Email Found',\r\n                    payload: 1\r\n                }\r\n            }\r\n\r\n            return connection.query('SELECT `u_email` FROM `accounts` WHERE u_email=?', [email.toLowerCase()]).then((res) => {\r\n                if (res.length !== 0) {\r\n                    return {\r\n                        msg: 'Fail - Duplicate Account',\r\n                        payload: 1\r\n                    }\r\n                }\r\n\r\n                // No duplicate found.\r\n                return {\r\n                    msg: 'Success',\r\n                    payload: 0\r\n                }\r\n            }).catch((e) => {\r\n                console.log(e);\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Find Account by Id\r\n     */\r\n    findAccountById(id) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('SELECT id, u_email, fullname FROM `accounts` WHERE id=?', [id]).then((res) => {\r\n                return res.length > 0 ? {\r\n                    name: res[0].fullname,\r\n                    email: res[0].u_email,\r\n                    msg: 'success'\r\n                } : false;\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Find Account By Id and also verify account status as being administrator.\r\n     */\r\n    findAccountByIdAdmin(id) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('SELECT id, u_email, fullname FROM `accounts` WHERE id=?', [id]).then((res) => {\r\n\r\n                // Check to see if there is an occurrence\r\n                if (res.length === 0) {\r\n                    return false\r\n                }\r\n\r\n                if (!res.hasOwnProperty('accountType') || res['accountType'] !== 2) {\r\n                    return false;\r\n                }\r\n\r\n                return {\r\n                    name: res[0].fullname,\r\n                    email: res[0].u_email,\r\n                    msg: 'success'\r\n                }\r\n            })\r\n        })\r\n    }\r\n\r\n    /**\r\n     * This is the last part of the system.\r\n     * All passwords should be ran through bcrypt before being inserted.\r\n     * @param email\r\n     * @param password\r\n     */\r\n    createAccount(email, password) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('INSERT INTO `accounts` (u_email, u_password, accountType) VALUES (?, ?, 1)', [email.toLowerCase(), password]).then((res) => {\r\n                return {msg: 'Success', payload: 10}\r\n            })\r\n        }).catch((e) => {\r\n            console.log(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Permanently removes an account from the system.\r\n     *\r\n     * Usage of this method should be heavily guarded as it is a standardized method that provides only base functionality with no security.\r\n     */\r\n    deleteAccount(email, password) {\r\n        return this.getUserPasswordHashWithEmail(email).then((res) => {\r\n\r\n            // No has is returned with false'y calls.\r\n            if (!res.hasOwnProperty('hash')) {\r\n                return res;\r\n            }\r\n\r\n            // Compare passwords.\r\n            return this.comparePasswords(res.hash, password).then((bool) => {\r\n                if (!bool) {\r\n                    return {msg: 'Incorrect password provided for account delete', payload: 1}\r\n                }\r\n\r\n                // Finally delete the account.\r\n                return Promise.using(getSqlConnection(), (connection) => {\r\n                    return connection.query('DELETE FROM `accounts` WHERE u_email=?', [email]).then((res) => {\r\n                        return {msg: 'Account Successfully Deleted.', payload: 0};\r\n                    })\r\n                });\r\n\r\n            }).catch((e) => {\r\n                console.log(e);\r\n            });\r\n        }).catch((e) => {\r\n            console.log(e);\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Gets the users hashed and salted password for the database.\r\n     * This method is only to be used when a validated user with an existing profile makes a call.\r\n     * @param userID\r\n     */\r\n    getUserPasswordHash(userID) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('SELECT u_password from `accounts` WHERE id=?', [userID]).then((res) => {\r\n                return {hash: res[0].u_password}\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Helper method that get's a user hash using there email address, to be used alongside deletion of an existing account.\r\n     * @param email\r\n     * @returns {Bluebird<any>}\r\n     */\r\n    getUserPasswordHashWithEmail(email) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('SELECT u_password from `accounts` WHERE u_email=?', [email]).then((res) => {\r\n                if (!res.length > 0) {\r\n                    return {msg: 'No Email found in accounts.', payload: 1};\r\n                }\r\n\r\n                return {hash: res[0].u_password};\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Inserts a new hashed password into the user account.\r\n     * @param id\r\n     * @param password\r\n     */\r\n    insertNewHashedPassword(id, password) {\r\n        return this.encryptPassword(password).then((hash) => {\r\n            return Promise.using(getSqlConnection(), (connection) => {\r\n                return connection.query('UPDATE `accounts` SET u_password=? WHERE id=?', [hash, id]).then(() => {\r\n                    return {\r\n                        status: 'ok',\r\n                        message: 'Password Changed!'\r\n                    }\r\n                })\r\n            })\r\n        })\r\n    }\r\n\r\n}\r\n"]}