{"version":3,"sources":["../../../library/Accounts/authenticationBase.js"],"names":["require","config","accounts","authenticationBase","process","env","ENVIROMENT","new","target","TypeError","password","hash","email","findAll","where","u_email","foundAccounts","length","msg","payload","comparePasswords","dataValues","u_password","res","user","id","plainText","compare","text","re","test","checkIfEmailInString","result","name","fullname","hasOwnProperty","accountType","auth","encryptPassword","pass","create","createdAccount","console","log","getUserPasswordHashWithEmail","then","bool","using","connection","query","catch","e","userID","status","message"],"mappings":"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","file":"authenticationBase.js","sourcesContent":["require('dotenv').config();\r\nimport 'babel-polyfill';\r\nimport getSqlConnection from '../../db/db';\r\nimport Promise from 'bluebird';\r\nimport bcrypt from 'bcrypt';\r\n// Database Class.\r\nimport db from '../../models/index';\r\n// Accounts Model\r\nconst accounts = db.accounts;\r\n\r\n/**\r\n * Abstract class that acts as the concrete functions for our registering api.\r\n */\r\nexport default class authenticationBase {\r\n\r\n    constructor() {\r\n        if (process.env.ENVIROMENT === 'production' && new.target === authenticationBase) {\r\n            throw new TypeError(\"Cannot construct Abstract instances directly\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encrypts plain text passwords using a safe encryption method.\r\n     * @param password String\r\n     */\r\n    async encryptPassword(password) {\r\n        return await bcrypt.hash(password, 10);\r\n    }\r\n\r\n\r\n    /**\r\n     * Validates a user from within the database.\r\n     * @param email\r\n     * @param password\r\n     */\r\n    async validateUser(email, password) {\r\n\r\n        let foundAccounts = await accounts.findAll({where: {u_email: email}});\r\n\r\n        if (foundAccounts.length > 0) {\r\n            return {\r\n                msg: 'Account or password did not match!',\r\n                payload: 1\r\n            }\r\n        }\r\n\r\n        let res = await this.comparePasswords(foundAccounts[0].dataValues.u_password, password);\r\n\r\n        if (!res) {\r\n            return {\r\n                msg: 'Account or password did not match!',\r\n                payload: 1\r\n            }\r\n        }\r\n\r\n        return {\r\n            msg: 'Success',\r\n            payload: 11,\r\n            user: {\r\n                id: foundAccounts[0].dataValues.id\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * This does a simple bcrypt comparision to identify correctness.\r\n     * @param hash\r\n     * @param plainText\r\n     */\r\n    async comparePasswords(hash, plainText) {\r\n        return await bcrypt.compare(plainText, hash);\r\n    }\r\n\r\n    /**\r\n     * Checks to make sure an email is present within a string.\r\n     * @param text\r\n     * @returns {boolean}\r\n     */\r\n    checkIfEmailInString(text) {\r\n        let re = /(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/;\r\n        return re.test(text);\r\n    }\r\n\r\n    /**\r\n     * This checks for a duplicate account inside the database.\r\n     * Payload is a boolean Int\r\n     */\r\n    async checkForDuplicateAccount(email) {\r\n        if (email.length < 5 || !this.checkIfEmailInString(email)) {\r\n            return {\r\n                msg: 'Fail - No Email Found',\r\n                payload: 1\r\n            }\r\n        }\r\n\r\n        let result = await accounts.findAll({\r\n            where: {\r\n                u_email: email\r\n            }\r\n        });\r\n\r\n        if (result.length !== 0) {\r\n            return {\r\n                msg: 'Fail - Duplicate Account',\r\n                payload: 1\r\n            }\r\n        }\r\n\r\n        // No duplicate found.\r\n        return {\r\n            msg: 'Success',\r\n            payload: 0\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find Account by Id\r\n     */\r\n    async findAccountById(id) {\r\n\r\n        let res = await accounts.findAll({\r\n            where: {\r\n                id: id\r\n            }\r\n        });\r\n\r\n        return res.length > 0 ? {\r\n            name: res[0].dataValues.fullname,\r\n            email: res[0].dataValues.u_email,\r\n            msg: 'success'\r\n        } : false;\r\n    }\r\n\r\n    /**\r\n     * Find Account By Id and also verify account status as being administrator.\r\n     */\r\n    async findAccountByIdAdmin(id) {\r\n\r\n        let res = await accounts.findAll({\r\n            where: {\r\n                id: id\r\n            }\r\n        });\r\n\r\n        // Check to see if there is an occurrence\r\n        if (res.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (!res[0].dataValues.hasOwnProperty('accountType') || res[0].dataValues.accountType !== 2) {\r\n            return false;\r\n        }\r\n\r\n        return {\r\n            name: res[0].dataValues.fullname,\r\n            email: res[0].dataValues.u_email,\r\n            accountType: res[0].dataValues.accountType,\r\n            msg: 'success'\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * This is the last part of the system.\r\n     * All passwords should be ran through bcrypt before being inserted.\r\n     * @param email\r\n     * @param password string\r\n     */\r\n    async createAccount(email, password) {\r\n        let pass = await auth.encryptPassword(password);\r\n        let createdAccount = await accounts.create({\r\n            u_email: email,\r\n            u_password: pass,\r\n            accountType: 1,\r\n            fullname: ''\r\n        });\r\n        console.log(createdAccount);\r\n        return {\r\n            msg: 'Success', payload: 10\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Permanently removes an account from the system.\r\n     *\r\n     * Usage of this method should be heavily guarded as it is a standardized method that provides only base functionality with no security.\r\n     */\r\n    deleteAccount(email, password) {\r\n        return this.getUserPasswordHashWithEmail(email).then((res) => {\r\n\r\n            // No has is returned with false'y calls.\r\n            if (!res.hasOwnProperty('hash')) {\r\n                return res;\r\n            }\r\n\r\n            // Compare passwords.\r\n            return this.comparePasswords(res.hash, password).then((bool) => {\r\n                if (!bool) {\r\n                    return {msg: 'Incorrect password provided for account delete', payload: 1}\r\n                }\r\n\r\n                // Finally delete the account.\r\n                return Promise.using(getSqlConnection(), (connection) => {\r\n                    return connection.query('DELETE FROM `accounts` WHERE u_email=?', [email]).then((res) => {\r\n                        return {msg: 'Account Successfully Deleted.', payload: 0};\r\n                    })\r\n                });\r\n\r\n            }).catch((e) => {\r\n                console.log(e);\r\n            });\r\n        }).catch((e) => {\r\n            console.log(e);\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Gets the users hashed and salted password for the database.\r\n     * This method is only to be used when a validated user with an existing profile makes a call.\r\n     * @param userID\r\n     */\r\n    getUserPasswordHash(userID) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('SELECT u_password from `accounts` WHERE id=?', [userID]).then((res) => {\r\n                return {hash: res[0].u_password}\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Helper method that get's a user hash using there email address, to be used alongside deletion of an existing account.\r\n     * @param email\r\n     * @returns {Bluebird<any>}\r\n     */\r\n    getUserPasswordHashWithEmail(email) {\r\n        return Promise.using(getSqlConnection(), (connection) => {\r\n            return connection.query('SELECT u_password from `accounts` WHERE u_email=?', [email]).then((res) => {\r\n                if (!res.length > 0) {\r\n                    return {msg: 'No Email found in accounts.', payload: 1};\r\n                }\r\n\r\n                return {hash: res[0].u_password};\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Inserts a new hashed password into the user account.\r\n     * @param id\r\n     * @param password\r\n     */\r\n    insertNewHashedPassword(id, password) {\r\n        return this.encryptPassword(password).then((hash) => {\r\n            return Promise.using(getSqlConnection(), (connection) => {\r\n                return connection.query('UPDATE `accounts` SET u_password=? WHERE id=?', [hash, id]).then(() => {\r\n                    return {\r\n                        status: 'ok',\r\n                        message: 'Password Changed!'\r\n                    }\r\n                })\r\n            })\r\n        })\r\n    }\r\n\r\n}\r\n"]}